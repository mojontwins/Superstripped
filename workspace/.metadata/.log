!SESSION 2025-07-15 16:37:48.308 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data D:\Cosas\MP125\superstripped\workspace -product org.eclipse.epp.package.java.product

This is a continuation of log file D:\Cosas\MP125\superstripped\workspace\.metadata\.bak_2.log
Created Time: 2025-07-15 23:34:14.959

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2025-07-15 23:34:14.960
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2025-07-15 23:34:14.960
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2025-07-15 23:34:16.649
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package net.minecraft.src;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.TreeMap;

public abstract class BiomeGenBase {
	public static TreeMap<Integer,List<BiomeGenBase>> biomeStructure = null;
	
	public static final BiomeGenBase[] biomeList = new BiomeGenBase[256];

	public static final BiomeGenBase alpha = (new BiomeGenAlpha(23)).setBiomeType(BiomeType.forest).setColor(2250012).setBiomeName("Alpha").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.5F,0.5F);
	public static final BiomeGenBase alphaCold = (new BiomeGenAlphaCold(24)).setBiomeType(BiomeType.veryCold).setColor(2250012).setBiomeName("Alpha Winter").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.1F,0.5F);
	
	public String biomeName;
	public int color;
	public byte topBlock = (byte)Block.grass.blockID;
	public byte fillerBlock = (byte)Block.dirt.blockID;
	public int biomeColor = 5169201;
	public float minHeight = 0.1F;
	public float maxHeight = 0.3F;
	public float temperature = 0.5F;
	public float rainfall = 0.5F;
	public int waterColorMultiplier = 0xFFFFFF;
	public BiomeDecorator biomeDecorator;
	protected List<SpawnListEntry> spawnableMonsterList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableWaterCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCaveCreatureList = new ArrayList<SpawnListEntry>();
	private boolean enableSnow;
	private boolean enableRain = true;
	public final int biomeID;
	protected WorldGenTrees worldGenTrees = new WorldGenTrees(false);
	protected WorldGenBigTree worldGenBigTree = new WorldGenBigTree(false);
	protected WorldGenForest worldGenForest = new WorldGenForest(false);
	protected WorldGenSwamp worldGenSwamp = new WorldGenSwamp();
	public BiomeType biomeType;
	
	protected Weather weather = Weather.normal;

	protected BiomeGenBase(int i1) {
		this.biomeID = i1;
		biomeList[i1] = this;
		
		this.biomeType = BiomeType.stitch;
		
		this.biomeDecorator = this.createBiomeDecorator();
		
		this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
		
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
		if(SoftLock.useNewAIMobs()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
		} else {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicSkeleton.class, 10, 4, 4));
		}
		this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
		
		if(SoftLock.enableEndermen()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
		}
				
		if(SoftLock.enableSquids()) {
			this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
		}
		
	}
	
	public byte getTopBlock(Random rand) {
		return this.topBlock;
	}
	
	public byte getFillBlock(Random rand) {
		return this.fillerBlock;
	}

	public BiomeGenBase setBiomeType(BiomeType biomeType) {
		this.biomeType = biomeType;
		return this;
	}
	
	protected BiomeDecorator createBiomeDecorator() {
		return new BiomeDecorator(this);
	}

	public BiomeGenBase setTemperatureRainfall(float f1, float f2) {
		/*if(f1 > 0.1F && f1 < 0.2F) {
			throw new IllegalArgumentException("Please avoid temperatures in the range 0.1 - 0.2 because of snow");
		} else*/ {
			this.temperature = f1;
			this.rainfall = f2;
			return this;
		}
	}
	
	public float getTerrainHeightVariance() {
		return this.maxHeight - this.minHeight;
	}

	public BiomeGenBase setMinMaxHeight(float f1, float f2) {
		this.minHeight = f1;
		this.maxHeight = f2;
		return this;
	}

	public BiomeGenBase setDisableRain() {
		this.enableRain = false;
		return this;
	}

	public WorldGenerator getRandomWorldGenForTrees(Random random1) {
		return (WorldGenerator)(random1.nextInt(10) == 0 ? this.worldGenBigTree : this.worldGenTrees);
	}

	public WorldGenerator getRandomWorldGenForGrass(Random random1) {
		return new WorldGenTallGrass(Block.tallGrass.blockID, 1);
	}

	public BiomeGenBase setEnableSnow() {
		this.enableSnow = true;
		return this;
	}

	public BiomeGenBase setBiomeName(String string1) {
		this.biomeName = string1;
		return this;
	}

	public BiomeGenBase setBiomeColor(int i1) {
		this.biomeColor = i1;
		return this;
	}

	public BiomeGenBase setColor(int i1) {
		this.biomeColor = i1;
		this.color = i1;
		return this;
	}

	public int getSkyColorByTemp(float f1) {
		f1 /= 3.0F;
		if(f1 < -1.0F) {
			f1 = -1.0F;
		}

		if(f1 > 1.0F) {
			f1 = 1.0F;
		}

		return Color.getHSBColor(0.62222224F - f1 * 0.05F, 0.5F + f1 * 0.1F, 1.0F).getRGB();
	}

	public List<SpawnListEntry> getSpawnableList(EnumCreatureType enumCreatureType1) {
		return enumCreatureType1 == EnumCreatureType.monster ? 
				this.spawnableMonsterList : 
					(enumCreatureType1 == EnumCreatureType.creature ? 
							this.spawnableCreatureList : 
								(enumCreatureType1 == EnumCreatureType.waterCreature ? 
										this.spawnableWaterCreatureList : 
											(enumCreatureType1 == EnumCreatureType.cave ? 
													this.spawnableCaveCreatureList :
														null)));
	}

	public boolean getEnableSnow() {
		return this.enableSnow;
	}

	public boolean canSpawnLightningBolt() {
		return this.enableSnow ? false : this.enableRain;
	}

	public boolean isHighHumidity() {
		return this.rainfall > 0.85F;
	}

	public float getSpawningChance() {
		return 0.1F;
	}

	public final int getIntRainfall() {
		return (int)(this.rainfall * 65536.0F);
	}

	public final int getIntTemperature() {
		return (int)(this.temperature * 65536.0F);
	}

	public final float getFloatRainfall() {
		return this.rainfall;
	}

	public final float getFloatTemperature() {
		return this.temperature;
	}

	public void decorate(World world1, Random random2, int i3, int i4, boolean hadFeature) {
		this.biomeDecorator.decorate(world1, random2, i3, i4, hadFeature);
	}

	public int getBiomeGrassColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerGrass.getGrassColor(d1, d3);
	}

	public int getBiomeFoliageColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFoliage.getFoliageColor(d1, d3);
	}

	public int getBiomeWaterColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerWater.getWaterColor(d1, d3);
	}
	
	public int getBiomeFogColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFog.getFogColor(d1, d3);
	}
	
	public String toString() {
		return this.biomeName;
	}
	
	public static int makeBiomeHash(BiomeGenBase biome) {
		return (((int)(biome.temperature * 100.0F)) << 8) | (int)(biome.rainfall * 100.0F);
	}
	
	public static float getTemperatureFromHash(Integer hash) {
		return (float)(hash >> 8) / 100.0F;
	}
	
	public static float getRainfallFromHash(Integer hash) {
		return (float)(hash & 0xFF) / 100.0F;
	}

	public static void buildBiomeStructure(BiomeGenBase[] biomesForWorldType) {
		biomeStructure = new TreeMap<Integer,List<BiomeGenBase>> ();
		
		for(BiomeGenBase biome : biomesForWorldType) {
			Integer hash = Integer.valueOf(makeBiomeHash(biome));
			if(!biomeStructure.containsKey(hash)) {
				biomeStructure.put(hash, new ArrayList<BiomeGenBase> ());
			}
			
			biomeStructure.get(hash).add(biome);
		}
		
		printBiomeStructure();
	}
	
	public static void printBiomeStructure() {
		   for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
		        List<BiomeGenBase> biomeList = entry.getValue();
		        Integer hash= entry.getKey();
		        
		        System.out.print ("[" + hash + "] (" + getTemperatureFromHash(hash) + ", " + getRainfallFromHash(hash) + ") ");
		        for(BiomeGenBase biome : biomeList) {
		        	System.out.print("<" + biome + "> ");
		        }
		        System.out.println();
		   }
	}

	public static int getClosestMatch(float tem, float hum, Random rand) {
		// Finds the closest t/h match in biomeStructure using euclidean distance.
		float minDistanceSq = Float.MAX_VALUE;
		Integer pickedHash = null;
		
		for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
			Integer hash= entry.getKey();
	        
	        float currentTem = getTemperatureFromHash(hash);
	        float currentHum = getRainfallFromHash(hash);
	        
	        float dt = currentTem - tem;
	        float dh = currentHum - hum;
	        float distanceSq = dt * dt + dh * dh;
	        if(distanceSq < minDistanceSq) {
	        	minDistanceSq = distanceSq;
	        	pickedHash = hash;
	        }
		}
		
		if(pickedHash != null) {
			List<BiomeGenBase> biomeList = biomeStructure.get(pickedHash);
			return biomeList.get(rand.nextInt(biomeList.size())).biomeID;
		} else {
			return alpha.biomeID;
		}
	}
	
	public void replaceBlocksForBiome(IChunkProvider generator, World world, Random rand, int chunkX, int chunkZ, int x, int z, byte[] blocks, byte[] metadata, int seaLevel, double sandNoise, double gravelNoise, double stoneNoise) {
		float temperature = this.getFloatTemperature();
		int height = (int)(stoneNoise / 3.0D + 3.0D + rand.nextDouble() * 0.25D);
		
		int stoneHeight = -1;
		byte topBlock = this.getTopBlock(rand);
		byte fillerBlock = this.getFillBlock(rand);

		for(int y = 127; y >= 0; --y) {
			int index = x << 11 | z << 7 | y; (x * 16 + z) * 128 + y;
			if(y <= 0 + this.rand.nextInt(5)) {
				blocks[index] = (byte)Block.bedrock.blockID;
			} else {
				byte blockID = blocks[index];
				if(blockID == 0) {
					stoneHeight = -1;
				} else if(blockID == Block.stone.blockID) {
					if(stoneHeight == -1) {
						if(height <= 0) {
							topBlock = 0;
							fillerBlock = (byte)Block.stone.blockID;
						} else if(y >= seaLevel - 4 && y <= seaLevel + 1) {
							topBlock = biomeGen.getTopBlock(this.rand);
							fillerBlock = biomeGen.getFillBlock(this.rand);
						}

						if(y < seaLevel && topBlock == 0) {
							if(temperature < 0.15F) {
								topBlock = (byte)Block.ice.blockID;
							} else {
								topBlock = (byte)Block.waterStill.blockID;
							}
						}

						stoneHeight = height;
						if(y >= seaLevel - 1) {
							blocks[index] = topBlock;
						} else {
							blocks[index] = fillerBlock;
						}
					} else if(stoneHeight > 0) {
						--stoneHeight;
						blocks[index] = fillerBlock;
						if(stoneHeight == 0 && fillerBlock == this.sandstoneGenTriggerer()) {
							stoneHeight = this.rand.nextInt(4);
							fillerBlock = this.sandstoneGenBlock();
						}
					}
				}
			}
		}
	}
	
	public byte sandstoneGenTriggerer() {
		return (byte)Block.sand.blockID;
	}
	
	public byte sandstoneGenBlock() {
		return (byte)Block.sandStone.blockID;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2025-07-15 23:34:16.649
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2025-07-15 23:34:16.650
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2025-07-15 23:34:16.725
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package net.minecraft.src;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.TreeMap;

public abstract class BiomeGenBase {
	public static TreeMap<Integer,List<BiomeGenBase>> biomeStructure = null;
	
	public static final BiomeGenBase[] biomeList = new BiomeGenBase[256];

	public static final BiomeGenBase alpha = (new BiomeGenAlpha(23)).setBiomeType(BiomeType.forest).setColor(2250012).setBiomeName("Alpha").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.5F,0.5F);
	public static final BiomeGenBase alphaCold = (new BiomeGenAlphaCold(24)).setBiomeType(BiomeType.veryCold).setColor(2250012).setBiomeName("Alpha Winter").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.1F,0.5F);
	
	public String biomeName;
	public int color;
	public byte topBlock = (byte)Block.grass.blockID;
	public byte fillerBlock = (byte)Block.dirt.blockID;
	public int biomeColor = 5169201;
	public float minHeight = 0.1F;
	public float maxHeight = 0.3F;
	public float temperature = 0.5F;
	public float rainfall = 0.5F;
	public int waterColorMultiplier = 0xFFFFFF;
	public BiomeDecorator biomeDecorator;
	protected List<SpawnListEntry> spawnableMonsterList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableWaterCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCaveCreatureList = new ArrayList<SpawnListEntry>();
	private boolean enableSnow;
	private boolean enableRain = true;
	public final int biomeID;
	protected WorldGenTrees worldGenTrees = new WorldGenTrees(false);
	protected WorldGenBigTree worldGenBigTree = new WorldGenBigTree(false);
	protected WorldGenForest worldGenForest = new WorldGenForest(false);
	protected WorldGenSwamp worldGenSwamp = new WorldGenSwamp();
	public BiomeType biomeType;
	
	protected Weather weather = Weather.normal;

	protected BiomeGenBase(int i1) {
		this.biomeID = i1;
		biomeList[i1] = this;
		
		this.biomeType = BiomeType.stitch;
		
		this.biomeDecorator = this.createBiomeDecorator();
		
		this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
		
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
		if(SoftLock.useNewAIMobs()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
		} else {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicSkeleton.class, 10, 4, 4));
		}
		this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
		
		if(SoftLock.enableEndermen()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
		}
				
		if(SoftLock.enableSquids()) {
			this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
		}
		
	}
	
	public byte getTopBlock(Random rand) {
		return this.topBlock;
	}
	
	public byte getFillBlock(Random rand) {
		return this.fillerBlock;
	}

	public BiomeGenBase setBiomeType(BiomeType biomeType) {
		this.biomeType = biomeType;
		return this;
	}
	
	protected BiomeDecorator createBiomeDecorator() {
		return new BiomeDecorator(this);
	}

	public BiomeGenBase setTemperatureRainfall(float f1, float f2) {
		/*if(f1 > 0.1F && f1 < 0.2F) {
			throw new IllegalArgumentException("Please avoid temperatures in the range 0.1 - 0.2 because of snow");
		} else*/ {
			this.temperature = f1;
			this.rainfall = f2;
			return this;
		}
	}
	
	public float getTerrainHeightVariance() {
		return this.maxHeight - this.minHeight;
	}

	public BiomeGenBase setMinMaxHeight(float f1, float f2) {
		this.minHeight = f1;
		this.maxHeight = f2;
		return this;
	}

	public BiomeGenBase setDisableRain() {
		this.enableRain = false;
		return this;
	}

	public WorldGenerator getRandomWorldGenForTrees(Random random1) {
		return (WorldGenerator)(random1.nextInt(10) == 0 ? this.worldGenBigTree : this.worldGenTrees);
	}

	public WorldGenerator getRandomWorldGenForGrass(Random random1) {
		return new WorldGenTallGrass(Block.tallGrass.blockID, 1);
	}

	public BiomeGenBase setEnableSnow() {
		this.enableSnow = true;
		return this;
	}

	public BiomeGenBase setBiomeName(String string1) {
		this.biomeName = string1;
		return this;
	}

	public BiomeGenBase setBiomeColor(int i1) {
		this.biomeColor = i1;
		return this;
	}

	public BiomeGenBase setColor(int i1) {
		this.biomeColor = i1;
		this.color = i1;
		return this;
	}

	public int getSkyColorByTemp(float f1) {
		f1 /= 3.0F;
		if(f1 < -1.0F) {
			f1 = -1.0F;
		}

		if(f1 > 1.0F) {
			f1 = 1.0F;
		}

		return Color.getHSBColor(0.62222224F - f1 * 0.05F, 0.5F + f1 * 0.1F, 1.0F).getRGB();
	}

	public List<SpawnListEntry> getSpawnableList(EnumCreatureType enumCreatureType1) {
		return enumCreatureType1 == EnumCreatureType.monster ? 
				this.spawnableMonsterList : 
					(enumCreatureType1 == EnumCreatureType.creature ? 
							this.spawnableCreatureList : 
								(enumCreatureType1 == EnumCreatureType.waterCreature ? 
										this.spawnableWaterCreatureList : 
											(enumCreatureType1 == EnumCreatureType.cave ? 
													this.spawnableCaveCreatureList :
														null)));
	}

	public boolean getEnableSnow() {
		return this.enableSnow;
	}

	public boolean canSpawnLightningBolt() {
		return this.enableSnow ? false : this.enableRain;
	}

	public boolean isHighHumidity() {
		return this.rainfall > 0.85F;
	}

	public float getSpawningChance() {
		return 0.1F;
	}

	public final int getIntRainfall() {
		return (int)(this.rainfall * 65536.0F);
	}

	public final int getIntTemperature() {
		return (int)(this.temperature * 65536.0F);
	}

	public final float getFloatRainfall() {
		return this.rainfall;
	}

	public final float getFloatTemperature() {
		return this.temperature;
	}

	public void decorate(World world1, Random random2, int i3, int i4, boolean hadFeature) {
		this.biomeDecorator.decorate(world1, random2, i3, i4, hadFeature);
	}

	public int getBiomeGrassColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerGrass.getGrassColor(d1, d3);
	}

	public int getBiomeFoliageColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFoliage.getFoliageColor(d1, d3);
	}

	public int getBiomeWaterColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerWater.getWaterColor(d1, d3);
	}
	
	public int getBiomeFogColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFog.getFogColor(d1, d3);
	}
	
	public String toString() {
		return this.biomeName;
	}
	
	public static int makeBiomeHash(BiomeGenBase biome) {
		return (((int)(biome.temperature * 100.0F)) << 8) | (int)(biome.rainfall * 100.0F);
	}
	
	public static float getTemperatureFromHash(Integer hash) {
		return (float)(hash >> 8) / 100.0F;
	}
	
	public static float getRainfallFromHash(Integer hash) {
		return (float)(hash & 0xFF) / 100.0F;
	}

	public static void buildBiomeStructure(BiomeGenBase[] biomesForWorldType) {
		biomeStructure = new TreeMap<Integer,List<BiomeGenBase>> ();
		
		for(BiomeGenBase biome : biomesForWorldType) {
			Integer hash = Integer.valueOf(makeBiomeHash(biome));
			if(!biomeStructure.containsKey(hash)) {
				biomeStructure.put(hash, new ArrayList<BiomeGenBase> ());
			}
			
			biomeStructure.get(hash).add(biome);
		}
		
		printBiomeStructure();
	}
	
	public static void printBiomeStructure() {
		   for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
		        List<BiomeGenBase> biomeList = entry.getValue();
		        Integer hash= entry.getKey();
		        
		        System.out.print ("[" + hash + "] (" + getTemperatureFromHash(hash) + ", " + getRainfallFromHash(hash) + ") ");
		        for(BiomeGenBase biome : biomeList) {
		        	System.out.print("<" + biome + "> ");
		        }
		        System.out.println();
		   }
	}

	public static int getClosestMatch(float tem, float hum, Random rand) {
		// Finds the closest t/h match in biomeStructure using euclidean distance.
		float minDistanceSq = Float.MAX_VALUE;
		Integer pickedHash = null;
		
		for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
			Integer hash= entry.getKey();
	        
	        float currentTem = getTemperatureFromHash(hash);
	        float currentHum = getRainfallFromHash(hash);
	        
	        float dt = currentTem - tem;
	        float dh = currentHum - hum;
	        float distanceSq = dt * dt + dh * dh;
	        if(distanceSq < minDistanceSq) {
	        	minDistanceSq = distanceSq;
	        	pickedHash = hash;
	        }
		}
		
		if(pickedHash != null) {
			List<BiomeGenBase> biomeList = biomeStructure.get(pickedHash);
			return biomeList.get(rand.nextInt(biomeList.size())).biomeID;
		} else {
			return alpha.biomeID;
		}
	}
	
	public void replaceBlocksForBiome(IChunkProvider generator, World world, Random rand, int chunkX, int chunkZ, int x, int z, byte[] blocks, byte[] metadata, int seaLevel, double sandNoise, double gravelNoise, double stoneNoise) {
		float temperature = this.getFloatTemperature();
		int height = (int)(stoneNoise / 3.0D + 3.0D + rand.nextDouble() * 0.25D);
		
		int stoneHeight = -1;
		byte topBlock = this.getTopBlock(rand);
		byte fillerBlock = this.getFillBlock(rand);

		for(int y = 127; y >= 0; --y) {
			int index = x << 11 | z << 7 | y; (x * 16 + z) * 128 + y;
			if(y <= 0 + this.rand.nextInt(5)) {
				blocks[index] = (byte)Block.bedrock.blockID;
			} else {
				byte blockID = blocks[index];
				if(blockID == 0) {
					stoneHeight = -1;
				} else if(blockID == Block.stone.blockID) {
					if(stoneHeight == -1) {
						if(height <= 0) {
							topBlock = 0;
							fillerBlock = (byte)Block.stone.blockID;
						} else if(y >= seaLevel - 4 && y <= seaLevel + 1) {
							topBlock = biomeGen.getTopBlock(this.rand);
							fillerBlock = biomeGen.getFillBlock(this.rand);
						}

						if(y < seaLevel && topBlock == 0) {
							if(temperature < 0.15F) {
								topBlock = (byte)Block.ice.blockID;
							} else {
								topBlock = (byte)Block.waterStill.blockID;
							}
						}

						stoneHeight = height;
						if(y >= seaLevel - 1) {
							blocks[index] = topBlock;
						} else {
							blocks[index] = fillerBlock;
						}
					} else if(stoneHeight > 0) {
						--stoneHeight;
						blocks[index] = fillerBlock;
						if(stoneHeight == 0 && fillerBlock == this.sandstoneGenTriggerer()) {
							stoneHeight = this.rand.nextInt(4);
							fillerBlock = this.sandstoneGenBlock();
						}
					}
				}
			}
		}
	}
	
	public byte sandstoneGenTriggerer() {
		return (byte)Block.sand.blockID;
	}
	
	public byte sandstoneGenBlock() {
		return (byte)Block.sandStone.blockID;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2025-07-15 23:34:16.726
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2025-07-15 23:34:16.726
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2025-07-15 23:34:17.661
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package net.minecraft.src;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.TreeMap;

public abstract class BiomeGenBase {
	public static TreeMap<Integer,List<BiomeGenBase>> biomeStructure = null;
	
	public static final BiomeGenBase[] biomeList = new BiomeGenBase[256];

	public static final BiomeGenBase alpha = (new BiomeGenAlpha(23)).setBiomeType(BiomeType.forest).setColor(2250012).setBiomeName("Alpha").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.5F,0.5F);
	public static final BiomeGenBase alphaCold = (new BiomeGenAlphaCold(24)).setBiomeType(BiomeType.veryCold).setColor(2250012).setBiomeName("Alpha Winter").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.1F,0.5F);
	
	public String biomeName;
	public int color;
	public byte topBlock = (byte)Block.grass.blockID;
	public byte fillerBlock = (byte)Block.dirt.blockID;
	public int biomeColor = 5169201;
	public float minHeight = 0.1F;
	public float maxHeight = 0.3F;
	public float temperature = 0.5F;
	public float rainfall = 0.5F;
	public int waterColorMultiplier = 0xFFFFFF;
	public BiomeDecorator biomeDecorator;
	protected List<SpawnListEntry> spawnableMonsterList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableWaterCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCaveCreatureList = new ArrayList<SpawnListEntry>();
	private boolean enableSnow;
	private boolean enableRain = true;
	public final int biomeID;
	protected WorldGenTrees worldGenTrees = new WorldGenTrees(false);
	protected WorldGenBigTree worldGenBigTree = new WorldGenBigTree(false);
	protected WorldGenForest worldGenForest = new WorldGenForest(false);
	protected WorldGenSwamp worldGenSwamp = new WorldGenSwamp();
	public BiomeType biomeType;
	
	protected Weather weather = Weather.normal;

	protected BiomeGenBase(int i1) {
		this.biomeID = i1;
		biomeList[i1] = this;
		
		this.biomeType = BiomeType.stitch;
		
		this.biomeDecorator = this.createBiomeDecorator();
		
		this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
		
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
		if(SoftLock.useNewAIMobs()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
		} else {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicSkeleton.class, 10, 4, 4));
		}
		this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
		
		if(SoftLock.enableEndermen()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
		}
				
		if(SoftLock.enableSquids()) {
			this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
		}
		
	}
	
	public byte getTopBlock(Random rand) {
		return this.topBlock;
	}
	
	public byte getFillBlock(Random rand) {
		return this.fillerBlock;
	}

	public BiomeGenBase setBiomeType(BiomeType biomeType) {
		this.biomeType = biomeType;
		return this;
	}
	
	protected BiomeDecorator createBiomeDecorator() {
		return new BiomeDecorator(this);
	}

	public BiomeGenBase setTemperatureRainfall(float f1, float f2) {
		/*if(f1 > 0.1F && f1 < 0.2F) {
			throw new IllegalArgumentException("Please avoid temperatures in the range 0.1 - 0.2 because of snow");
		} else*/ {
			this.temperature = f1;
			this.rainfall = f2;
			return this;
		}
	}
	
	public float getTerrainHeightVariance() {
		return this.maxHeight - this.minHeight;
	}

	public BiomeGenBase setMinMaxHeight(float f1, float f2) {
		this.minHeight = f1;
		this.maxHeight = f2;
		return this;
	}

	public BiomeGenBase setDisableRain() {
		this.enableRain = false;
		return this;
	}

	public WorldGenerator getRandomWorldGenForTrees(Random random1) {
		return (WorldGenerator)(random1.nextInt(10) == 0 ? this.worldGenBigTree : this.worldGenTrees);
	}

	public WorldGenerator getRandomWorldGenForGrass(Random random1) {
		return new WorldGenTallGrass(Block.tallGrass.blockID, 1);
	}

	public BiomeGenBase setEnableSnow() {
		this.enableSnow = true;
		return this;
	}

	public BiomeGenBase setBiomeName(String string1) {
		this.biomeName = string1;
		return this;
	}

	public BiomeGenBase setBiomeColor(int i1) {
		this.biomeColor = i1;
		return this;
	}

	public BiomeGenBase setColor(int i1) {
		this.biomeColor = i1;
		this.color = i1;
		return this;
	}

	public int getSkyColorByTemp(float f1) {
		f1 /= 3.0F;
		if(f1 < -1.0F) {
			f1 = -1.0F;
		}

		if(f1 > 1.0F) {
			f1 = 1.0F;
		}

		return Color.getHSBColor(0.62222224F - f1 * 0.05F, 0.5F + f1 * 0.1F, 1.0F).getRGB();
	}

	public List<SpawnListEntry> getSpawnableList(EnumCreatureType enumCreatureType1) {
		return enumCreatureType1 == EnumCreatureType.monster ? 
				this.spawnableMonsterList : 
					(enumCreatureType1 == EnumCreatureType.creature ? 
							this.spawnableCreatureList : 
								(enumCreatureType1 == EnumCreatureType.waterCreature ? 
										this.spawnableWaterCreatureList : 
											(enumCreatureType1 == EnumCreatureType.cave ? 
													this.spawnableCaveCreatureList :
														null)));
	}

	public boolean getEnableSnow() {
		return this.enableSnow;
	}

	public boolean canSpawnLightningBolt() {
		return this.enableSnow ? false : this.enableRain;
	}

	public boolean isHighHumidity() {
		return this.rainfall > 0.85F;
	}

	public float getSpawningChance() {
		return 0.1F;
	}

	public final int getIntRainfall() {
		return (int)(this.rainfall * 65536.0F);
	}

	public final int getIntTemperature() {
		return (int)(this.temperature * 65536.0F);
	}

	public final float getFloatRainfall() {
		return this.rainfall;
	}

	public final float getFloatTemperature() {
		return this.temperature;
	}

	public void decorate(World world1, Random random2, int i3, int i4, boolean hadFeature) {
		this.biomeDecorator.decorate(world1, random2, i3, i4, hadFeature);
	}

	public int getBiomeGrassColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerGrass.getGrassColor(d1, d3);
	}

	public int getBiomeFoliageColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFoliage.getFoliageColor(d1, d3);
	}

	public int getBiomeWaterColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerWater.getWaterColor(d1, d3);
	}
	
	public int getBiomeFogColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFog.getFogColor(d1, d3);
	}
	
	public String toString() {
		return this.biomeName;
	}
	
	public static int makeBiomeHash(BiomeGenBase biome) {
		return (((int)(biome.temperature * 100.0F)) << 8) | (int)(biome.rainfall * 100.0F);
	}
	
	public static float getTemperatureFromHash(Integer hash) {
		return (float)(hash >> 8) / 100.0F;
	}
	
	public static float getRainfallFromHash(Integer hash) {
		return (float)(hash & 0xFF) / 100.0F;
	}

	public static void buildBiomeStructure(BiomeGenBase[] biomesForWorldType) {
		biomeStructure = new TreeMap<Integer,List<BiomeGenBase>> ();
		
		for(BiomeGenBase biome : biomesForWorldType) {
			Integer hash = Integer.valueOf(makeBiomeHash(biome));
			if(!biomeStructure.containsKey(hash)) {
				biomeStructure.put(hash, new ArrayList<BiomeGenBase> ());
			}
			
			biomeStructure.get(hash).add(biome);
		}
		
		printBiomeStructure();
	}
	
	public static void printBiomeStructure() {
		   for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
		        List<BiomeGenBase> biomeList = entry.getValue();
		        Integer hash= entry.getKey();
		        
		        System.out.print ("[" + hash + "] (" + getTemperatureFromHash(hash) + ", " + getRainfallFromHash(hash) + ") ");
		        for(BiomeGenBase biome : biomeList) {
		        	System.out.print("<" + biome + "> ");
		        }
		        System.out.println();
		   }
	}

	public static int getClosestMatch(float tem, float hum, Random rand) {
		// Finds the closest t/h match in biomeStructure using euclidean distance.
		float minDistanceSq = Float.MAX_VALUE;
		Integer pickedHash = null;
		
		for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
			Integer hash= entry.getKey();
	        
	        float currentTem = getTemperatureFromHash(hash);
	        float currentHum = getRainfallFromHash(hash);
	        
	        float dt = currentTem - tem;
	        float dh = currentHum - hum;
	        float distanceSq = dt * dt + dh * dh;
	        if(distanceSq < minDistanceSq) {
	        	minDistanceSq = distanceSq;
	        	pickedHash = hash;
	        }
		}
		
		if(pickedHash != null) {
			List<BiomeGenBase> biomeList = biomeStructure.get(pickedHash);
			return biomeList.get(rand.nextInt(biomeList.size())).biomeID;
		} else {
			return alpha.biomeID;
		}
	}
	
	public void replaceBlocksForBiome(IChunkProvider generator, World world, Random rand, int chunkX, int chunkZ, int x, int z, byte[] blocks, byte[] metadata, int seaLevel, double sandNoise, double gravelNoise, double stoneNoise) {
		float temperature = this.getFloatTemperature();
		int height = (int)(stoneNoise / 3.0D + 3.0D + rand.nextDouble() * 0.25D);
		
		int stoneHeight = -1;
		byte topBlock = this.getTopBlock(rand);
		byte fillerBlock = this.getFillBlock(rand);

		for(int y = 127; y >= 0; --y) {
			int index = x << 11 | z << 7 | y; (x * 16 + z) * 128 + y;
			if(y <= 0 + this.rand.nextInt(5)) {
				blocks[index] = (byte)Block.bedrock.blockID;
			} else {
				byte blockID = blocks[index];
				if(blockID == 0) {
					stoneHeight = -1;
				} else if(blockID == Block.stone.blockID) {
					if(stoneHeight == -1) {
						if(height <= 0) {
							topBlock = 0;
							fillerBlock = (byte)Block.stone.blockID;
						} else if(y >= seaLevel - 4 && y <= seaLevel + 1) {
							topBlock = biomeGen.getTopBlock(this.rand);
							fillerBlock = biomeGen.getFillBlock(this.rand);
						}

						if(y < seaLevel && topBlock == 0) {
							if(temperature < 0.15F) {
								topBlock = (byte)Block.ice.blockID;
							} else {
								topBlock = (byte)Block.waterStill.blockID;
							}
						}

						stoneHeight = height;
						if(y >= seaLevel - 1) {
							blocks[index] = topBlock;
						} else {
							blocks[index] = fillerBlock;
						}
					} else if(stoneHeight > 0) {
						--stoneHeight;
						blocks[index] = fillerBlock;
						if(stoneHeight == 0 && fillerBlock == this.sandstoneGenTriggerer()) {
							stoneHeight = this.rand.nextInt(4);
							fillerBlock = this.sandstoneGenBlock();
						}
					}
				}
			}
		}
	}
	
	public byte sandstoneGenTriggerer() {
		return (byte)Block.sand.blockID;
	}
	
	public byte sandstoneGenBlock() {
		return (byte)Block.sandStone.blockID;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2025-07-15 23:34:17.661
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2025-07-15 23:34:17.662
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2025-07-15 23:34:17.691
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package net.minecraft.src;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.TreeMap;

public abstract class BiomeGenBase {
	public static TreeMap<Integer,List<BiomeGenBase>> biomeStructure = null;
	
	public static final BiomeGenBase[] biomeList = new BiomeGenBase[256];

	public static final BiomeGenBase alpha = (new BiomeGenAlpha(23)).setBiomeType(BiomeType.forest).setColor(2250012).setBiomeName("Alpha").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.5F,0.5F);
	public static final BiomeGenBase alphaCold = (new BiomeGenAlphaCold(24)).setBiomeType(BiomeType.veryCold).setColor(2250012).setBiomeName("Alpha Winter").setEnableSnow().setMinMaxHeight(0.0F,2.0F).setTemperatureRainfall(0.1F,0.5F);
	
	public String biomeName;
	public int color;
	public byte topBlock = (byte)Block.grass.blockID;
	public byte fillerBlock = (byte)Block.dirt.blockID;
	public int biomeColor = 5169201;
	public float minHeight = 0.1F;
	public float maxHeight = 0.3F;
	public float temperature = 0.5F;
	public float rainfall = 0.5F;
	public int waterColorMultiplier = 0xFFFFFF;
	public BiomeDecorator biomeDecorator;
	protected List<SpawnListEntry> spawnableMonsterList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableWaterCreatureList = new ArrayList<SpawnListEntry>();
	protected List<SpawnListEntry> spawnableCaveCreatureList = new ArrayList<SpawnListEntry>();
	private boolean enableSnow;
	private boolean enableRain = true;
	public final int biomeID;
	protected WorldGenTrees worldGenTrees = new WorldGenTrees(false);
	protected WorldGenBigTree worldGenBigTree = new WorldGenBigTree(false);
	protected WorldGenForest worldGenForest = new WorldGenForest(false);
	protected WorldGenSwamp worldGenSwamp = new WorldGenSwamp();
	public BiomeType biomeType;
	
	protected Weather weather = Weather.normal;

	protected BiomeGenBase(int i1) {
		this.biomeID = i1;
		biomeList[i1] = this;
		
		this.biomeType = BiomeType.stitch;
		
		this.biomeDecorator = this.createBiomeDecorator();
		
		this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
		this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
		
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
		if(SoftLock.useNewAIMobs()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
		} else {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicZombie.class, 10, 4, 4));
			this.spawnableMonsterList.add(new SpawnListEntry(EntityClassicSkeleton.class, 10, 4, 4));
		}
		this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
		this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
		
		if(SoftLock.enableEndermen()) {
			this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
		}
				
		if(SoftLock.enableSquids()) {
			this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
		}
		
	}
	
	public byte getTopBlock(Random rand) {
		return this.topBlock;
	}
	
	public byte getFillBlock(Random rand) {
		return this.fillerBlock;
	}

	public BiomeGenBase setBiomeType(BiomeType biomeType) {
		this.biomeType = biomeType;
		return this;
	}
	
	protected BiomeDecorator createBiomeDecorator() {
		return new BiomeDecorator(this);
	}

	public BiomeGenBase setTemperatureRainfall(float f1, float f2) {
		/*if(f1 > 0.1F && f1 < 0.2F) {
			throw new IllegalArgumentException("Please avoid temperatures in the range 0.1 - 0.2 because of snow");
		} else*/ {
			this.temperature = f1;
			this.rainfall = f2;
			return this;
		}
	}
	
	public float getTerrainHeightVariance() {
		return this.maxHeight - this.minHeight;
	}

	public BiomeGenBase setMinMaxHeight(float f1, float f2) {
		this.minHeight = f1;
		this.maxHeight = f2;
		return this;
	}

	public BiomeGenBase setDisableRain() {
		this.enableRain = false;
		return this;
	}

	public WorldGenerator getRandomWorldGenForTrees(Random random1) {
		return (WorldGenerator)(random1.nextInt(10) == 0 ? this.worldGenBigTree : this.worldGenTrees);
	}

	public WorldGenerator getRandomWorldGenForGrass(Random random1) {
		return new WorldGenTallGrass(Block.tallGrass.blockID, 1);
	}

	public BiomeGenBase setEnableSnow() {
		this.enableSnow = true;
		return this;
	}

	public BiomeGenBase setBiomeName(String string1) {
		this.biomeName = string1;
		return this;
	}

	public BiomeGenBase setBiomeColor(int i1) {
		this.biomeColor = i1;
		return this;
	}

	public BiomeGenBase setColor(int i1) {
		this.biomeColor = i1;
		this.color = i1;
		return this;
	}

	public int getSkyColorByTemp(float f1) {
		f1 /= 3.0F;
		if(f1 < -1.0F) {
			f1 = -1.0F;
		}

		if(f1 > 1.0F) {
			f1 = 1.0F;
		}

		return Color.getHSBColor(0.62222224F - f1 * 0.05F, 0.5F + f1 * 0.1F, 1.0F).getRGB();
	}

	public List<SpawnListEntry> getSpawnableList(EnumCreatureType enumCreatureType1) {
		return enumCreatureType1 == EnumCreatureType.monster ? 
				this.spawnableMonsterList : 
					(enumCreatureType1 == EnumCreatureType.creature ? 
							this.spawnableCreatureList : 
								(enumCreatureType1 == EnumCreatureType.waterCreature ? 
										this.spawnableWaterCreatureList : 
											(enumCreatureType1 == EnumCreatureType.cave ? 
													this.spawnableCaveCreatureList :
														null)));
	}

	public boolean getEnableSnow() {
		return this.enableSnow;
	}

	public boolean canSpawnLightningBolt() {
		return this.enableSnow ? false : this.enableRain;
	}

	public boolean isHighHumidity() {
		return this.rainfall > 0.85F;
	}

	public float getSpawningChance() {
		return 0.1F;
	}

	public final int getIntRainfall() {
		return (int)(this.rainfall * 65536.0F);
	}

	public final int getIntTemperature() {
		return (int)(this.temperature * 65536.0F);
	}

	public final float getFloatRainfall() {
		return this.rainfall;
	}

	public final float getFloatTemperature() {
		return this.temperature;
	}

	public void decorate(World world1, Random random2, int i3, int i4, boolean hadFeature) {
		this.biomeDecorator.decorate(world1, random2, i3, i4, hadFeature);
	}

	public int getBiomeGrassColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerGrass.getGrassColor(d1, d3);
	}

	public int getBiomeFoliageColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFoliage.getFoliageColor(d1, d3);
	}

	public int getBiomeWaterColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerWater.getWaterColor(d1, d3);
	}
	
	public int getBiomeFogColor() {
		double d1 = (double)MathHelper.clamp_float(this.getFloatTemperature(), 0.0F, 1.0F);
		double d3 = (double)MathHelper.clamp_float(this.getFloatRainfall(), 0.0F, 1.0F);
		return ColorizerFog.getFogColor(d1, d3);
	}
	
	public String toString() {
		return this.biomeName;
	}
	
	public static int makeBiomeHash(BiomeGenBase biome) {
		return (((int)(biome.temperature * 100.0F)) << 8) | (int)(biome.rainfall * 100.0F);
	}
	
	public static float getTemperatureFromHash(Integer hash) {
		return (float)(hash >> 8) / 100.0F;
	}
	
	public static float getRainfallFromHash(Integer hash) {
		return (float)(hash & 0xFF) / 100.0F;
	}

	public static void buildBiomeStructure(BiomeGenBase[] biomesForWorldType) {
		biomeStructure = new TreeMap<Integer,List<BiomeGenBase>> ();
		
		for(BiomeGenBase biome : biomesForWorldType) {
			Integer hash = Integer.valueOf(makeBiomeHash(biome));
			if(!biomeStructure.containsKey(hash)) {
				biomeStructure.put(hash, new ArrayList<BiomeGenBase> ());
			}
			
			biomeStructure.get(hash).add(biome);
		}
		
		printBiomeStructure();
	}
	
	public static void printBiomeStructure() {
		   for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
		        List<BiomeGenBase> biomeList = entry.getValue();
		        Integer hash= entry.getKey();
		        
		        System.out.print ("[" + hash + "] (" + getTemperatureFromHash(hash) + ", " + getRainfallFromHash(hash) + ") ");
		        for(BiomeGenBase biome : biomeList) {
		        	System.out.print("<" + biome + "> ");
		        }
		        System.out.println();
		   }
	}

	public static int getClosestMatch(float tem, float hum, Random rand) {
		// Finds the closest t/h match in biomeStructure using euclidean distance.
		float minDistanceSq = Float.MAX_VALUE;
		Integer pickedHash = null;
		
		for (Map.Entry<Integer,List<BiomeGenBase>> entry : biomeStructure.entrySet()) {
			Integer hash= entry.getKey();
	        
	        float currentTem = getTemperatureFromHash(hash);
	        float currentHum = getRainfallFromHash(hash);
	        
	        float dt = currentTem - tem;
	        float dh = currentHum - hum;
	        float distanceSq = dt * dt + dh * dh;
	        if(distanceSq < minDistanceSq) {
	        	minDistanceSq = distanceSq;
	        	pickedHash = hash;
	        }
		}
		
		if(pickedHash != null) {
			List<BiomeGenBase> biomeList = biomeStructure.get(pickedHash);
			return biomeList.get(rand.nextInt(biomeList.size())).biomeID;
		} else {
			return alpha.biomeID;
		}
	}
	
	public void replaceBlocksForBiome(IChunkProvider generator, World world, Random rand, int chunkX, int chunkZ, int x, int z, byte[] blocks, byte[] metadata, int seaLevel, double sandNoise, double gravelNoise, double stoneNoise) {
		float temperature = this.getFloatTemperature();
		int height = (int)(stoneNoise / 3.0D + 3.0D + rand.nextDouble() * 0.25D);
		
		int stoneHeight = -1;
		byte topBlock = this.getTopBlock(rand);
		byte fillerBlock = this.getFillBlock(rand);

		for(int y = 127; y >= 0; --y) {
			int index = x << 11 | z << 7 | y; (x * 16 + z) * 128 + y;
			if(y <= 0 + this.rand.nextInt(5)) {
				blocks[index] = (byte)Block.bedrock.blockID;
			} else {
				byte blockID = blocks[index];
				if(blockID == 0) {
					stoneHeight = -1;
				} else if(blockID == Block.stone.blockID) {
					if(stoneHeight == -1) {
						if(height <= 0) {
							topBlock = 0;
							fillerBlock = (byte)Block.stone.blockID;
						} else if(y >= seaLevel - 4 && y <= seaLevel + 1) {
							topBlock = biomeGen.getTopBlock(this.rand);
							fillerBlock = biomeGen.getFillBlock(this.rand);
						}

						if(y < seaLevel && topBlock == 0) {
							if(temperature < 0.15F) {
								topBlock = (byte)Block.ice.blockID;
							} else {
								topBlock = (byte)Block.waterStill.blockID;
							}
						}

						stoneHeight = height;
						if(y >= seaLevel - 1) {
							blocks[index] = topBlock;
						} else {
							blocks[index] = fillerBlock;
						}
					} else if(stoneHeight > 0) {
						--stoneHeight;
						blocks[index] = fillerBlock;
						if(stoneHeight == 0 && fillerBlock == this.sandstoneGenTriggerer()) {
							stoneHeight = this.rand.nextInt(4);
							fillerBlock = this.sandstoneGenBlock();
						}
					}
				}
			}
		}
	}
	
	public byte sandstoneGenTriggerer() {
		return (byte)Block.sand.blockID;
	}
	
	public byte sandstoneGenBlock() {
		return (byte)Block.sandStone.blockID;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2025-07-15 23:34:17.692
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2025-07-15 23:34:17.692
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2025-07-16 22:25:26.769
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2025-07-17 12:59:28.203 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2025-07-17 12:59:55.403
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2025-07-17 12:59:55.403
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@33356666,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3a988299,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2025-07-17 13:00:04.655
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\na_th'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.ucdetector 1 1 2025-07-17 13:11:44.776
!MESSAGE UCDetector found 4856 warnings. See reports in: D:\Cosas\MP125\superstripped\workspace\.ucdetector_reports.

!ENTRY org.eclipse.debug.ui 4 120 2025-07-17 20:06:46.795
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2025-07-18 14:16:02.935
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
